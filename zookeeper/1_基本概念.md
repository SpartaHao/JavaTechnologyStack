## 1. 简单介绍下zookeeper
ZooKeeper（注：ZooKeeper是著名Hadoop的一个子项目，是一个**开源的分布式协调服务，旨在解决大规模分布式应用场景下，服务协调同步（Coordinate Service）的问题**；
它可以为同在一个分布式系统中的其他服务提供：**统一命名服务、配置管理、分布式锁服务、leader选举、集群管理等功能**。

ZooKeeper 是一个典型的**分布式数据一致性**的解决方案，致力于提供一个高性能、高可用、具有严格的顺序访问控制能力的分布式协调服务，具有如下分布式一致性特性：
* **顺序一致性**：从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到ZooKeeper中去。
* **原子性**：要么整个集群所有机器都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。
* **单一视图**：无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。
* **可靠性**：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。
* **实时性**：ZooKeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。

由于**zookeeper将全量的数据存储在内存中，并直接服务于客户端的所有非事务请求，因此它尤其适用于以读操作为主的场景**。  
客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。
**对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功**。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。

有序性是 zookeeper 中非常重要的一个特性，**所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid**（Zookeeper Transaction Id）。而读请求只会相对于更新有序，
也就是读请求的返回结果中会带有这个zookeeper 最新的 zxid。

## 2. Zookeeper 文件系统
Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些**节点都可以设置关联的数据**，而文件系统中只有文件节点可以存放数据而目录节点不行。  
Zookeeper 为了保证高吞吐和低延迟，**在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M**。

## 3. 服务器角色？
#### Leader
（1）事务请求的唯一调度和处理者，保证集群事务处理的顺序性  
（2）集群内部各服务的调度者  

#### Follower
（1）处理客户端的非事务请求，转发事务请求给 Leader 服务器  
（2）参与事务请求 Proposal 的投票  
（3）参与 Leader 选举投票  

#### Observer
（1）3.0 版本以后引入的一个服务器角色，**在不影响集群事务处理能力的基础上提升集群的非事务处理能力**  
（2）处理客户端的非事务请求，转发事务请求给 Leader 服务器  
（3）不参与任何形式的投票  

## 4. Zookeeper的节点有哪几种类型？
Zookeeper的数据存储结构就像一棵树，这棵树由节点组成，这种节点叫做Znode。Znode分为四种类型：  
1. 持久节点 （PERSISTENT）
默认的节点类型。该数据节点被创建后，会一直存在于zookeeper服务器上，直到有删除操作来主动清除这个节点；

2. 持久节点顺序节点（PERSISTENT_SEQUENTIAL）
所谓顺序节点，就是在创建节点时，Zookeeper会自动在节点名后面追加一个整形数字，这个整型数字是一个由父节点维护的自增数字； 

3. 临时节点（EPHEMERAL）
**临时节点的生命周期和客户端的会话绑定在一起**。和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除；zookeeper规定了不能基于临时节点来创建子节点，即**临时节点只能作为叶子节点**；

4. 临时顺序节点（EPHEMERAL_SEQUENTIAL）
顾名思义，临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。

## 5. zookeeper的watch机制？
zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定的时间触发的时候，zookeeper服务端会将事件通知到感兴趣的客户端上，该机制是zookeeper实现分布式协调服务的重要特性。

zookeeper 的 watcher 机制，可以分为四个过程：
* 客户端注册Watcher到服务端;
* 服务端发生数据变更;
* 服务端通知客户端数据变更;
* 客户端回调Watcher处理变更应对逻辑;
其中客户端注册 watcher 有三种方式，调用客户端 API 可以分别通过 **getData、exists、getChildren** 实现。
	
监视有两种类型：**数据监视点和子节点监视点**。创建、删除或者设置znode都会触发这些监视点。exists,getData 可以设置监视点。getChildren 可以设置子节点变化。
	
而可能监测的事件类型有: **NodeCreated, NodeDataChanged, NodeDeleted, NodeChildrenChanged**. 
	
#### Watcher 特性：
* **一次性：watch是一次性触发器**。客户端在Znode设置了Watch时，如果Znode内容发生改变，那么客户端就会获得Watch事件。例如：客户端设置getData("/znode1", true)后，如果/znode1发生改变或者删除，那么客户端就会得到一个/znode1的Watch事件，但是/znode1再次发生变化，那客户端是无法收到Watch事件的，除非客户端设置了新的Watch。这样的设计**有效的减轻了服务端的压力**，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。二是在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。

* 客户端串行执行：客户端 Watcher 回调的过程是一个串行同步的过程。

* 轻量：  
1）Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。  
2）客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。
	
* Watch事件是异步发送到Client。Zookeeper可以保证客户端发送过去的更新顺序是有序的。由于Watch有一次性触发的特点，所以在服务器端没有Watcher的情况下，Znode的任何变更就不会通知到客户端。不过，即使某个Znode设置了Watcher，且在Znode有变化的情况下通知到了客户端，但是在客户端接收到这个变化事件，但是还没有再次设置Watcher之前，如果其他客户端对该Znode做了修改，这种情况下，Znode第二次的变化客户端是无法收到通知的。这可能是由于网络延迟或者是其他因素导致，所以我们**使用Zookeeper不能期望能够监控到节点每次的变化**。Zookeeper只能保证最终的一致性，而无法保证强一致性。


## 6. Zookeeper 下 Server 工作状态？
在ZAB协议的设计中，每一个进程都有可能处于以下四种状态之一。  
* L00KING:   Leader选举阶段; 寻 找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。
* FOLLOWING:   Follower服务器和Leader保持同步状态;
* LEADING:   Leader服务器作为主进程领导状态;
* OBSERVING：观察者状态。表明当前服务器角色是 Observer。

组成ZAB协议的所有进程启动的时候，其初始化状态都是LOOKING状态，此时进程组中不存在Leader。所有处于这种状态的进程，都会试图去选举出一个新的Leader。随后**如果进程发现已经选举出新的Leader了，那么它就会马上切换到FOLLOWlNG状态，并开始和Leader保持同步**。假如5台机器集群，1,2,3依次启动，3成为了leader，4起来后是looking状态，投给自己，但是1,2,3都投给了3,已经有leader了，4就变为follower。这里，我们将处于FOLLOWING状态的进程称为Follower,将处于LEADING状态的进程称为Leader。  
考虑到Leader进程随时会挂掉，**当检测出Leader已经崩溃或者是放弃了领导地位时，其余的Follower进程就会转换到LOOKING状态，并开始进行新一轮的Leader选举**。因此在ZAB协议运行过程中，每个进程都会在LEADlNG、FOLLOWING和LOOKING状态之间不断地转换。

需要注意的是，**只有在完成了阶段二，即完成各进程之间的数据同步之后，准Leader进程才能真正成为新的主进程周期中的Leader。完成Leader选举以及数据同步之后，ZAB协议就进入了原子广播阶段**。在这一阶段中，Leader会以队列的形式为每一个与自己保持同步的Follower创建一个操作队列。同一时刻，一个Follower只能和一个Leader保持同步，Leader进程与所有的Follower进程之间都通过心跳检测机制来感知彼此的情况。如果Leader能够在超时时间内正常收到心跳检测，那么Follower就会一直与该Leader保持连接。而**如果在指定的超时时间内Leader无法从过半的FolIower进程那里接收到心跳检测，或者是TCP连接本身断开了，那么Leader就会终止对当前周期的领导，并转换到LOOKING状态**，所有的Follower也会选择放弃这个Leader，同时转换到LOOKING状态。之后，所有进程就会开始新一轮的Leader选举，并在选举产生新的Leader之后开始新一轮的主进程周期。

## 7. Leader和Learner之间是如何进行交互的呢？（了解）
zookeeper的客户端和服务端之间会建立**TCP长连接**来进行网络通信。基于该TCP连接衍生出来的会话概念，是客户端和服务端之间所有请求与响应交互的基石。**leader服务器会负责管理每个会话的生命周期，包括会话的创建、心跳检测和销毁等**。

**在服务器启动阶段，会进行磁盘数据的恢复，完成数据恢复后就会进行Leader选举。一旦选举产生Leader服务器后，就立即开始进行集群间的数据同步，在整个过程中，zooKeeper都处于不可用状态，直到数据同步完毕（集群中绝大部分机器数据和Leader一致）,ZooKeePer才可以对外提供正常服务**。在运行期间，如果Leader服务器所在的机器挂掉或是和集群中绝大部分服务器断开连接，那么就会触发新一轮的Leader选举。同样，在新的Leader服务器选举产生之前，ZooKeeper无法对外提供服务。

一个正常运行的ZooKeeper集群，其机器角色通常由Leader、Follower和Observer组成。ZooKeeper对于客户端请求的处理，严格按照ZAB协议规范来进行。每一个服务器在启动初始化阶段都会组装一个请求处理链，**Leader服务器能够处理所有类型的客户端请求；而对Follower或是Observer服务器来说，可以正常处理非事务请求，而事务请求则需要转发给Ieader服务器来处理，同时，对于每个事务请求，Leader都会为其分配一个全局唯一且递增的ZXID，以此来保证事务处理的顺序性。在事务请求的处理过程中，Leader和Follower服务器都会进行事务日志的记录。**

**Follower和Observer统称为Learner**。Leader和Learner两者之间的交互采用的是一种典型1+N的线程模型。即**一个线程用来处理连接请求，然后N个线程用来处理彼此之间的io**。
两个线程：LearnerCnxAcceptor、LearnerHandler；  
LearnerCnxAcceptor是一个Follower接收器，专门用来接受来自Learner的连接请求。  
Leader接受来自其他服务器的连接请求之后，会创建一个LearnerHandler实例，每个LearnerHandler的实例都对应着一个Learner和Leader之间的连接，主要负责两者之间的消息通信以及数据同步。总结一下，一个线程专门处理连接请求，然后有多少个连接，就创建多少个LearnerHandler线程。

## 8. zk的内存模型、事务日志、快照文件？
**DataTree是zookeeper内存数据存储的核心，是一个“树”的数据结构，代表了内存中一份完整的数据**。DataTree的底层数据结构是**concurrentHashMap**,以数据节点的路径(path)为key，value则是节点的数据内容(DataNode)。

ZKDatabase是zookeeper的内存数据库，负责管理zookeeper的所有会话，DataTree存储和事务日志。**ZKDatabase会定时向磁盘dump快照数据，同时在Zookeeper服务器启动的时候，会通过磁盘上的事务日志和快照数据文件恢复成一个完整的内存数据库**。

针对客户端的每一次事务操作，ZooKeeper都会将它们记录到事务日志中，当然，ZooKeeper同时也会将数据变更应用到内存数据库中。另外，**ZooKeePer会在进行若干次事务日志记录之后，将内存数据库的全量数据Dump到本地文件中，这个过程就是数据快照**。可以使用snapCount参数来配置每次数据快照之间的事务操作次数，默认为100000,即ZooKeeper会在snapCount次事务日志记录后进行一个数据快照（**实际上采用的是“过半随机策略”，即符合如下条件就进行数据快照：logCount>(snapCount/2+randRoll)**）。

**数据快照用来记录zookeeper服务器上某一个时刻全量的内存数据内容，并将其写入到指定的磁盘文件中**。

