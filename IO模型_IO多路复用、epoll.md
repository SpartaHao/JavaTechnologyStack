## 18. 什么是IO多路复用？
**IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄**；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。

**IO事件的特点是当不满足某些条件时会阻塞**，当程序运行碰到阻塞IO时，会等待阻塞结束再继续运行。如果有很多IO事件，当前事件是阻塞状态，但是第二个IO事件是非阻塞状态可以直接执行的，程序还是会等第一个IO事件运行结束再执行第二个IO事件。要是此时第二个IO事件又变成阻塞状态了，程序又要等待它阻塞结束，这样是很浪费时间的，明明可以先执行不阻塞的IO事件效率最高。

IO多路复用有效地解决了这一尴尬的难题，其基本原理是**应用程序把所有待执行的IO事件交给操作系统内核，然后由内核轮询这些IO事件，碰到准备就绪的再返给应用程序执行**。**多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符**。通常使用select，poll和epoll这三种方法实现IO多路复用，其中select方法跨平台性最强，Windows、Unix、Linux都能使用。poll方法在Unix、Linux都能使用。epoll只能在Linux环境下使用。
> 其中epoll效率是最高的，因为**select和poll都是把待执行IO事件先放在应用程序的一个列表里，再一起映射给内核，内核轮询完以后，返回给应用的也是整个列表，而epoll是直接把待执行IO事件交给内核处理，内核处理完返回的只有其中准备就绪的IO事件，所以效率极高**。而且epoll是支持边缘触发的，而其它两种方法只支持水平触发。边缘触发指的是当内核把准备就绪的IO事件返给应用时，如果下次轮询到此事件时该事件没有发生任何的变化（说明应用还没有做任何处理），即使该事件还是准备就绪也不会返回给应用。而水平触发是内核每次轮询到准备就绪的IO事件都会返给应用，无论应用是否处理过（也许来不及处理，也许不想处理）。

## 19. Select，poll，epoll的区别？
select，poll，epoll都是IO多路复用的机制。**I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作**。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

通过select的方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（**多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用**）。但是select有以下三点不足：
1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）
1. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）
1. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）

epoll 主要就是针对select的三个缺点进行了改进。
1. **内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可**。
1. 内核不再通过轮询的方式找到就绪的文件描述符，而是**通过异步 IO 事件唤醒**。
1. 内核**仅会将有 IO 事件的文件描述符返回给用户**，用户也无需遍历整个文件描述符集合。

详细对比：
1. **poll本质上和select基本没有区别**，唯一区别它没有最大连接数的限制，原因是它是基于链表来存储的
1. select单个进程所打开的FD是有限制的，通过FD_SETSIZE设置，**默认1024**；而epoll没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；
1. epoll效率是最高的，因为**select和poll都是把待执行IO事件先放在应用程序的一个列表里，再一起映射给内核，内核轮询完以后，返回给应用的也是整个列表。它仅仅知道了，有I/O事件发生了，却并不知道是哪几个流**（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作，同时处理的流越多，无差别轮询时间就越长。而**epoll是直接把待执行IO事件交给内核处理，内核处理完返回的只有其中准备就绪的IO事件**（只需关注活跃的链接），所以效率极高。epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。
1. select/poll 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。而**epoll是在内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可**；
1. **相比于select/poll，epoll支持边缘触发，效率更高**。如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符
1. 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。
1. epoll只能在linux下运行，poll 可以在linux、unix下运行，而select 是跨平台性最好， windows、unix、linux都可以运行

好多文章说，多路复用之所以效率高，是因为用一个线程就可以监控多个文件描述符。这显然是知其然而不知其所以然，多路复用产生的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 read 函数实现。**而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符**。
就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。
来自 <https://blog.csdn.net/coderising/article/details/115258181> 

select/poll/epoll之间的区别：

	        select	   poll	   epoll

数据结构      | bitmap	  | 数组	  | 红黑树

最大连接数	| 1024	   | 无上限  | 无上限

fd拷贝	  | 每次调用select拷贝	| 每次调用poll拷贝	| fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝

工作效率	| 轮询：O(n)	| 轮询：O(n)	| 回调：O(1)

来自 <https://cloud.tencent.com/developer/article/1681177> 

