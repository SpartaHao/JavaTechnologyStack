## 18. 什么是IO多路复用？
**IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄**；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。

**IO事件的特点是当不满足某些条件时会阻塞**，当程序运行碰到阻塞IO时，会等待阻塞结束再继续运行。如果有很多IO事件，当前事件是阻塞状态，但是第二个IO事件是非阻塞状态可以直接执行的，程序还是会等第一个IO事件运行结束再执行第二个IO事件。要是此时第二个IO事件又变成阻塞状态了，程序又要等待它阻塞结束，这样是很浪费时间的，明明可以先执行不阻塞的IO事件效率最高。

IO多路复用有效地解决了这一尴尬的难题，其基本原理是**应用程序把所有待执行的IO事件交给操作系统内核，然后由内核轮询这些IO事件，碰到准备就绪的再返给应用程序执行**。**多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符**。通常使用select，poll和epoll这三种方法实现IO多路复用，其中select方法跨平台性最强，Windows、Unix、Linux都能使用。poll方法在Unix、Linux都能使用。epoll只能在Linux环境下使用。
> 其中epoll效率是最高的，因为**select和poll都是把待执行IO事件先放在应用程序的一个列表里，再一起映射给内核，内核轮询完以后，返回给应用的也是整个列表，而epoll是直接把待执行IO事件交给内核处理，内核处理完返回的只有其中准备就绪的IO事件，所以效率极高**。而且epoll是支持边缘触发的，而其它两种方法只支持水平触发。边缘触发指的是当内核把准备就绪的IO事件返给应用时，如果下次轮询到此事件时该事件没有发生任何的变化（说明应用还没有做任何处理），即使该事件还是准备就绪也不会返回给应用。而水平触发是内核每次轮询到准备就绪的IO事件都会返给应用，无论应用是否处理过（也许来不及处理，也许不想处理）。

## 19. Select，poll，epoll的区别？
select，poll，epoll都是IO多路复用的机制。**I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作**。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

通过select的方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（**多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用**）。但是select有以下三点不足：
1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）
1. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）
1. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）

epoll 主要就是针对select的三个缺点进行了改进。
1. **内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可**。
1. 内核不再通过轮询的方式找到就绪的文件描述符，而是**通过异步 IO 事件唤醒**。
1. 内核**仅会将有 IO 事件的文件描述符返回给用户**，用户也无需遍历整个文件描述符集合。

详细对比：
1. **poll本质上和select基本没有区别**，唯一区别它没有最大连接数的限制，原因是它是基于链表来存储的
1. select单个进程所打开的FD是有限制的，通过FD_SETSIZE设置，**默认1024**；而epoll没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；
1. epoll效率是最高的，因为**select和poll都是把待执行IO事件先放在应用程序的一个列表里，再一起映射给内核，内核轮询完以后，返回给应用的也是整个列表。它仅仅知道了，有I/O事件发生了，却并不知道是哪几个流**（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作，同时处理的流越多，无差别轮询时间就越长。而**epoll是直接把待执行IO事件交给内核处理，内核处理完返回的只有其中准备就绪的IO事件**（只需关注活跃的链接），所以效率极高。epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。
1. select/poll 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。而**epoll是在内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可**；
1. **相比于select/poll，epoll支持边缘触发，效率更高**。如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符
1. 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。
1. epoll只能在linux下运行，poll 可以在linux、unix下运行，而select 是跨平台性最好， windows、unix、linux都可以运行

好多文章说，多路复用之所以效率高，是因为用一个线程就可以监控多个文件描述符。这显然是知其然而不知其所以然，多路复用产生的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 read 函数实现。**而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符**。
就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。
来自 <https://blog.csdn.net/coderising/article/details/115258181> 

select/poll/epoll之间的区别：

 类别 | select | poll | epoll
 ---- | ---- | ---- | ----
数据结构   |  bitmap  |  数组  |  红黑树  
最大连接数 | 1024     | 无上限 | 无上限
fd拷贝  | 每次调用select拷贝	| 每次调用poll拷贝	| fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝 
工作效率| 轮询：O(n)  | 轮询：O(n)	| 回调：O(1)  

来自 <https://cloud.tencent.com/developer/article/1681177> 

select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，**epoll_create,epoll_ctl和epoll_wait**：
* epoll_create是创建一个epoll句柄；
* epoll_ctl：向内核添加、修改或删除要监控的文件描述符。
* epoll_wait则是等待事件的产生；

### 20. epoll 水平触发（LT）与 边缘触发（ET）的区别？在什么场景下使用？
* epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。
* LT(Level_triggered)模式下，**只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作**；当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大**降低处理程序检索自己关心的就绪文件描述符的效率**！！！
* **ET(Edge_triggered)模式下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读**。当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你（）！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！！**所以在ET模式下，read一个fd的时候一定要把它的buffer读完，或者遇到EAGAIN错误**;

举例说明:一个管道收到了1kb的数据,epoll会立即返回,此时读了512字节数据,然后再次调用epoll，这时如果是水平触发的,epoll会立即返回,因为有数据准备好了.如果是边缘触发的不会立即返回,因为此时虽然有数据可读但是已经触发了一次通知,在这次通知到现在还没有新的数据到来,直到有新的数据到来epoll才会返回,此时老的数据和新的数据都可以读取到(当然是需要这次你尽可能的多读取).所以当我们写epoll网络模型时，如果我们**用水平触发不用担心数据有没有读完，因为下次epoll返回时，没有读完的socket依然会被返回**，但是要注意这种模式下的写事件，因为是水平触发，每次socket可写时epoll都会返回，当我们写的数据包过大时，一次写不完，要多次才能写完或者每次socket写都写一个很小的数据包时，每次写都会被epoll检测到，因此长期关注socket写事件会无故cpu消耗过大甚至导致cpu跑满，所以在水平触发模式下我们一般不关注socket可写事件而是通过调用socket write或者send api函数来写socket，说到这我们可以看到这种模式在**效率上是没有边缘触发高的，因为每个socket读或者写可能被返回两次甚至多次**，所以有时候我们也会用到边缘触发，但是这种模式下在读数据的时候一定要注意，因为如果一次可写事件我们没有把数据读完，如果没有读完，在socket没有新的数据可读时epoll就不回返回了，只有在新的数据到来时，我们才能读取到上次没有读完的数据。

**select(),poll()模型都是水平触发模式，信号驱动IO是边缘触发模式，epoll()模型即支持水平触发，也支持边缘触发，默认是水平触发**。

参考文件：

https://blog.csdn.net/qq_34793133/article/details/82055915

https://cloud.tencent.com/developer/article/1681177
