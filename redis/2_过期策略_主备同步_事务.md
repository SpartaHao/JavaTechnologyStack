## 16. Redis的过期策略怎么实现的？
### redis设置过期时间：  
**expire key time**(以秒为单位)--这是最常用的方式，除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间，如果没有设置时间，那缓存就是永不过期  
**setex(String key, int seconds, String value)**--字符串独有的方式  

### 三种过期策略：
#### 定时删除
含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除  

优点：保证内存被尽快释放  

缺点：若过期key很多，删除这些key会占用很多的CPU时间，在单线程CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key定时器的创建耗时，
**若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重**;  

#### 懒汉式删除
含义：**key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null**（用的时候再检查删除）。  

优点：删除操作只发生在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）  

缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么**可能发生内存泄露**（无用的垃圾占用了大量的内存）;
        
#### 定期删除
含义：每隔一段时间执行一次删除过期key操作

优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用

缺点：在内存友好方面，不如"定时删除"（会造成一定的内存占用，但是没有懒汉式那么占用内存）;  
在CPU时间友好方面，不如"懒汉式删除"（会定期的去进行比较和删除操作，cpu方面不如懒汉式，但是比定时好）

### Redis的过期策略
Redis 采用的是**定期删除+惰性删除**策略。**然后定期加惰性还不生效的话，在采用内存淘汰机制**。

> 懒汉式删除流程：    
* 在进行get或setnx等操作时，先检查key是否过期；
* 若过期，删除key，然后执行相应操作；
* 若没过期，直接执行相应操作；

> 定期删除流程：简单而言，**对指定个数个库的每一个库随机删除小于等于指定个数个过期key**。  

**Redis 默认会每秒进行十次过期扫描**，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略：  
* 从过期字典中随机 20 个 key；
* 删除这 20 个 key 中已经过期的 key；
* 如果过期的 key 比率超过 1/4，那就重复步骤 1；

同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了**扫描时间的上限，默认不会超过 25ms**。  
如果某一时刻，有大量key同时过期，Redis 会持续扫描过期字典，造成客户端响应卡顿，因此设置过期时间时，就尽量避免这个问题，**在设置过期时间时，可以给过期时间设置一个随机范围，避免同一时刻过期**。

#### 如何配置定期删除执行时间间隔
redis的定时任务默认是1s执行十次，如果要修改这个值，可以在redis.conf中修改hz的值。  
**redis.conf中，hz默认设为10，提高它的值将会占用更多的cpu**，当然相应的redis将会更快的处理同时到期的许多key，以及更精确的去处理超时。
hz的取值范围是1~500，通常不建议超过100，只有在请求延时非常低的情况下可以将值提升到100。

#### 从节点过期key是如何删除的呢？
主节点在key到期时，会在AOF文件里增加一条del指令。AOF文件被同步到从节点以后，从节点根据AOF中的这个del指令来执行删除过期key的操作。  
从节点的这个过期key的处理策略，会导致一个问题，**主节点已经删除的key，在从节点还是存在的。因为AOF同步del指令是异步的**。  
还有一个关键点，《redis深度》历险那本书这样写的：从节点不会过期扫描，从节点对过期的处理是被动的。

## 17. aof/rdb和复制功能对过期键的处理
### rdb
生成rdb文件：**生成时，程序会对键进行检查，过期键不放入rdb文件**。  

载入rdb文件：载入时，如果以主服务器模式运行，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会忽略；
如果以从服务器模式运行，无论键过期与否，均会载入数据库中，过期键会通过与主服务器同步而删除。

### aof
当服务器以aof持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被删除，那么aof文件不会因为这个过期键而产生任何影响；当过期键被删除后，程序会向aof文件追加一条del命令来显式记录该键已被删除。

**aof重写过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的aof文件中**。

### 复制
当服务器运行在复制模式下时，**从服务器的过期删除动作由主服务器控制**：  
* 主服务器在删除一个过期键后，会显式地向所有从服务器发送一个del命令，告知从服务器删除这个过期键;
* 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键;
* 从服务器只有在接到主服务器发来的del命令后，才会删除过期键。

## 18. Redis的主备同步流程？
### 1)初次全量同步
当一个redis服务器初次向主服务器发送salveof命令时，redis从服务器会进行一次全量同步，同步的步骤如下图所示：  

![psync](https://img-blog.csdnimg.cn/20190124133223141.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzI0Njkx,size_16,color_FFFFFF,t_70)

* slave服务器向master发送psync命令（此时发送的是psync ? -1），告诉master我需要同步数据了。
* master接收到psync命令后会进行**BGSAVE命令生成RDB文件快照**。
* 生成完后，会将RDB文件发送给slave。
* slave接收到文件会**载入RDB快照，并且将数据库状态变更为master在执行BGSAVE时的状态一致**。
* master会**发送保存在缓冲区里的所有写命令**，告诉slave可以进行同步了
* slave执行这些写命令。

### 2)命令传播
slave已经同步过master了，那么如果后续master进行了写操作，比如说一个简单的set name redis，那么master执行过当前命令后，会将当前命令发送给slave执行一遍，达成数据一致性

### 3)重新复制
**当slave断开重连之后会进行重新同步，重新同步分完全同步和部分同步**。master需要根据以下三点判断是否进行部分同步： 

* 服务器运行ID   
每个redis服务器开启后会生成运行ID。  
当进行初次同步时，master会将自己的ID告诉slave，slave会记录下来，当slave断线重连后，发现ID是这个master的就会尝试进行部分重同步。**当ID与现在连接的master不一样时会进行完整重同步**。

* 复制偏移量   
复制偏移量包括master复制偏移量和slave复制偏移量，当初次同步过后两个数据库的复制偏移量相同，之后master执行一次写命令，那么master的偏移量+1，
master将写命令给slave，slave执行一次，slave偏移量+1，这样版本就能一致。

* 复制积压缓冲区    
复制积压缓冲区是由master维护的固定长度的先进先出的队列。当slave发送psync，会将自己的偏移量也发送给master，**当slave的偏移量之后的数据在缓冲区还存在，就会返回+continue通知slave进行部分重同步。
当slave的偏移量之后的数据不在缓冲区了，就会进行完整重同步**。

#### 总流程如下： 
* 当slave断开重连后，会发送psync 命令给master。
* master首先会对服务器运行id进行判断，如果与自己相同就进行判断偏移量
* master会判断自己的偏移量与slave的偏移量是否一致。
* 如果不一致，master会去缓冲区中判断slave的偏移量之后的数据是否存在。
* 如果存在就会返回+continue回复，表示slave可以执行部分同步了。
* master发送断线后的写命令给slave
* slave执行写命令。

### 主从同步最终流程

![syncprocess](https://img-blog.csdnimg.cn/20190123192757690.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzI0Njkx,size_16,color_FFFFFF,t_70)

https://blog.csdn.net/qq_41724691/article/details/86616266?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328603.59861.16152051071033153&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control


##  19. Redis的事务怎么实现？有什么缺点？
### 事务基本概念
Redis事务提供了一种“**将多个命令打包， 然后一次性、按顺序地执行**”的机制， 并且**事务在执行的期间不会主动中断** —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。
一个事务从开始到执行会经历以下三个阶段：**开始事务、命令入队、执行事务**。
1. MULTI 命令的执行标记着事务的开始，这个命令唯一做的就是将客户端的 REDIS_MULTI 选项打开， 让客户端从非事务状态切换到事务状态。
1. 当客户端处于非事务状态下时， 所有发送给服务器端的命令都会立即被服务器执行。但是当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 QUEUED ， 表示命令已入队。
1. 如果客户端正处于事务状态， 那么当 EXEC 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（**FIFO**）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。
1. 当事务队列里的所有命令被执行完之后， EXEC 命令会将回复队列作为自己的执行结果返回给客户端， 客户端从事务状态返回到非事务状态， 至此， 事务执行完毕。

###  事务相关的命令：MULTI、EXEC、DISCARD、WATCH。
* DISCARD 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 OK 给客户端， 说明事务已被取消。
* WATCH 命令用于在**事务开始之前**监视任意数量的键： 当调用 EXEC 命令执行事务时， **如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败**。
* 带 WATCH 命令的事务会将客户端和被监视的键在数据库的 watched_keys 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 选项打开。
只有在客户端的 REDIS_DIRTY_CAS 选项未被打开时，才能执行事务，否则事务直接返回失败。

### 事务和非事务状态下执行命令的区别
无论在事务状态下， 还是在非事务状态下， Redis 命令都由同一个函数执行， 所以它们共享很多服务器的一般设置， 比如 AOF 的配置、RDB 的配置，以及内存限制，等等。  
不过事务中的命令和普通命令在执行上还是有一点区别的，其中最重要的两点是：
* **非事务状态下的命令以单个命令为单位执行**，前一个命令和后一个命令的客户端不一定是同一个；
* 而事务状态则是以一个事务为单位，执行事务队列中的所有命令：**除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令**。
* 在非事务状态下，执行命令所得的结果会立即被返回给客户端；
* 而事务则是将所有命令的结果集合到回复队列，再作为 EXEC 命令的结果返回给客户端。

### redis事务的特征
在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的安全性。**Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）**。
* 原子性：**单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的**，
**redis事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做**。
* 如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。**当事务失败时，Redis 也不会进行任何的重试或者回滚动作**；
还有就是如果事务队列中，有个别命令存在语法错误，那么执行命令的时候，其他命令是可以正常执行的，并不是要么全部执行成功，要么不执行。
* 隔离性：Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。
