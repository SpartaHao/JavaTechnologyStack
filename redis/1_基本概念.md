## 1. 什么是Redis？简述它的优缺点？
Redis全称为：Remote Dictionary Server（远程字典服务），Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。
支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

其本质上是一个是一个开源（BSD许可）的、**Key-Value类型、高性能非关系型（NoSQL）内存数据库**，使用C编写，很像memcached，
**整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存**。因为是纯内存操作，**Redis的性能非常出色，每秒可以处理超过 10万次读写操作**，
是已知性能最快的Key-Value DB，因此redis被广泛应用于缓存方向。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外一个字符串类型的值能存储最大容量是512M，
不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。
另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一个功能加强版的memcached来用，还有用来实现分布式锁等。 
	
### 优点
* 读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。
* 支持数据持久化，支持AOF和RDB两种持久化方式。
* 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
* 数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。
* 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。

### 缺点
* 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此**Redis适合的场景主要局限在较小数据量的高性能操作和运算上。**
* **Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败**，需要等待机器重启或者手动切换前端的IP才能恢复。
* 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
* **Redis 较难支持在线扩容**，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费
	
https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/redis/%E7%9C%8B%E5%AE%8C%E8%BF%9920%E9%81%93Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E5%8F%AF%E4%BB%A5%E7%BA%A6%E8%B5%B7%E6%9D%A5%E4%BA%86.md#2redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84

## 2. 为什么要用 Redis（缓存）？
* **高性能**：从数据库读取数据是读的硬盘，比较慢，而缓存是直接操作内存，所以速度相当快，可以提高接口响应速度。我们在碰到需要执行耗时特别久，且结果不频繁变动的 SQL，
就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。
* **高并发**：在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库，
**直接操作缓存能够承受的请求是远远大于直接访问数据库的**

## 3. Redis相比memcached有哪些优势？
* Memcached基本只支持简单的key-value存储，redis作为其替代者，支持更为丰富的数据类型
* redis的速度比memcached快很多（单核）。由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，
Memcached性能要高于Redis，虽然Redis也在存储大数据的性能上进行了优化，但是比起Memcached，还是稍有逊色。
* redis可以持久化其数据，memcached不支持持久化和复制等功能
* 一个字符串类型的值能存储最大容量是512M，不像 memcached只能保存1MB的数据

## 4. 为什么要用 Redis 而不用 map/guava 做缓存?
* 缓存分为本地缓存和分布式缓存。以 Java 为例，使用**自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束**，并且在多实例的情况下，
每个实例都需要各自保存一份缓存，缓存不具有一致性。
* **使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性**。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。

## 5. 为什么Redis需要把所有数据放到内存中？
**Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘**。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O 速度会严重影响性能。
在内存越来越便宜的今天，redis将会越来越受欢迎。redis的maxmemory参数用于控制redis可使用的最大内存容量。如果超过maxmemory的值，就会动用淘汰策略来清理数据。maxmemory-policy设置淘汰策略。

## 6. redis这么快，为何是单线程的？
Redis确实是单进程单线程的模型，因为**Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽**。
既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了，毕竟采用多线程会有很多麻烦。

## 7. Redis是单线程的，为什么还能这么快？
* **纯内存操作**，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；
* **采用单线程，避免了频繁的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作**，没有因为可能出现死锁而导致的性能消耗；
* **采用了非阻塞 I/O 多路复用机制**；

## 8. Redis支持的Java客户端都有哪些？官方推荐用哪个？
Redisson、Jedis、lettuce等等，**官方推荐使用Redisson**。

## 9. Redis和Redisson有什么关系？Jedis与Redisson对比有什么优缺点？
Redis 其实并没有对 Java 提供原生支持。作为 Java 开发人员，我们若想在程序中集成 Redis，必须使用 Redis 的第三方库。而 **Redisson 就是用于在 Java 程序中操作 Redis 的库**，
它使得我们可以在程序中轻松地使用 Redis。Redisson 在 java.util 中常用接口的基础上，为我们提供了一系列具有分布式特性的工具类（比如我们用的RRateLimiter，Bloom filter），
从而让使用者能够将精力更集中地放在处理业务逻辑上。

Redisson是一个高级的分布式协调Redis客户端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。

Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；  
**Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性**。
Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

## 10. 修改配置不重启Redis会实时生效吗？
针对运行实例，**有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启**。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。
检索 ‘CONFIG GET \*’ 命令获取更多信息。  
但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。

## 11. 单线程的redis，如何知道要运行定时任务？
redis是单线程的，线程不但要处理定时任务，还要处理客户端请求，线程不能阻塞在定时任务或处理客户端请求上，那么，redis是如何知道何时该运行定时任务的呢？  
**Redis 的定时任务会记录在一个称为最小堆的数据结构中**。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处理。
处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是接下来处理客户端请求的最大时长，若达到了该时长，则暂时不处理客户端请求而去运行定时任务。

## 12. Redis的性能瓶颈在哪？
因为redis是单线程，所以Redis的性能和CPU无关。其性能瓶颈一般在两个地方：  
其一是**机器内存大小**，内存大小关系到Redis存储的数据量  
其二是**网络带宽**。Redis客户端执行一条命令分为四个过程：**发送命令、命令排队、命令执行、返回结果**。  
而其中发送命令+返回结果这一过程被称为Round Trip Time（RTT，往返时间），Redis的客户端和服务端可能部署在不同的机器上，如果两地间隔太远的话，RTT会耗时比较久。

## 13. 缓存数据redis满了怎么办？
1. 加内存  
这是最简单粗暴的办法, 不过成本相对较高
2. 内存淘汰策略  
redis的内存淘汰策略是指在Redis的用于缓存的内存不足时, 怎么处理需要新写入且需要申请额外空间的数据.    
maxmemory参数: 设置内存的最大使用量(配置)  
maxmemory-policy参数: 对应的内存淘汰规则(配置), 当内存不够用时, 会设置的内存淘汰规则  
3. 集群  
slaveof 从机替换主机, 主机下来后做相应的操作  
配置多主多从

## 14. Redis能否实现乐观锁？
锁可以分为乐观锁和悲观锁:  
所谓悲观锁，就是一个线程在修改某一个数据的时候，**悲观地认为肯定会有其他线程也进行修改，怎么办呢，干脆我直接独占**，等我修改完了，其他线程再去抢占，所以，这种锁性能不是很好，不适合对并发性要求高的场景。

所谓乐观锁，就是一个线程在修改某一个数据的时候，**乐观地认为不会有其他线程进行修改，直接修改，然后再提交的时候检查一下是否有人修改过原来的数据(通过version)**，
如果有人修改过，那我就放弃修改，返回失败，或者重试，所以，这种比较宽松的加锁机制，性能显然要好一些。

**Redis中可以通过Watch命令来实现乐观锁**。Watch会监视指定的key，并会发觉这些键是否被改动过了。**如果在一个事务中开始执行之前，其他的客户端对已经监视的key进行了修改，那么当前事务就丢弃它的修改**。

## 15. Redis的内存淘汰策略？
* noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
* allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（推荐使用，目前项目在用这种）(最近最久使用算法)
* allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。（应该也没人用吧，你不删最少使用 Key，去随机删）
* volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。（不推荐）
* volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。（依然不推荐）
* volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。（不推荐）

**用作缓存的数据都是设置了过期时间的, 没有过期时间那不叫缓存, 那叫持久化。在redis3.0之前，默认是volatile-lru；在redis3.0之后（包括3.0），默认淘汰策略则是noeviction。**
