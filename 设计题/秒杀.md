## 1. 如何设计一个秒杀系统？
秒杀系统抽象来说就是以下几个步骤：  
	• 用户选定商品下单  
	• 校验库存  
	• 扣库存  
	• 创建用户订单  
	• 用户支付等后续步骤…  

秒杀可能存在的问题：**高并发、超卖、恶意请求、链接暴露、库存遗留**

#### 服务单一职责：
单一职责的好处就是就算秒杀没抗住，秒杀库崩了，服务挂了，也不会影响到其他的服务。（强行高可用）

#### 秒杀链接加盐：
链接要是提前暴露出去可能有人直接访问url就提前秒杀，为了避免这种情况的发生，把URL动态化，就连写代码的人都不知道，你就通过MD5之类的加密算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。

#### Redis集群：
Redis集群，主从同步、读写分离，我们还搞点哨兵，开启持久化直接无敌高可用！作为数据库的缓冲

#### Nginx：
多部署几台服务器，使用nginx做负载均衡。

恶意请求拦截也需要用到它，一般单个用户请求次数太夸张，不像人为的请求在网关那一层就得拦截掉了，不然请求多了他抢不抢得到是一回事，服务器压力上去了，可能占用网络带宽或者把服务器打崩、缓存击穿等等。**通过nginx限制单IP指定时间的调用次数**。

也可以通过redis等缓存框架做到，列入以某个接口+用户唯一性标准为key，可以选择value为string类型，如果缓存更多数据，value可以选择hash类型，value的值是int类型，这样用户每次访问接口，
可以先判断该值有没有达到预设的访问频率限制的值，如果达到了，就告诉用户，你的访问太过频繁，请多长时间后再试，或者要求用户输入验证码（图片验证码或者短信验证码）。  

#### 前端资源静态化：
按钮控制：**秒杀前，一般按钮都是置灰的，只有时间到了，才能点击**。这是因为怕大家在时间快到的最后几秒疯狂请求服务器，然后还没到秒杀的时候基本上服务器就挂了。
**按钮可以点击之后也得给他置灰几秒**，不然他一样在开始之后一直点的。

#### 限流：
限流这里我觉得应该分为前端限流和后端限流。

**前端限流**：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。

**后端限流**：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。

Tip：真正的限流还会有限流组件的加入例如：阿里的Sentinel、Hystrix等。我这里就不展开了，就说一下物理的限流。

#### 库存预热：
秒杀前你通过定时任务或者运维同学**提前把商品的库存加载到Redis中去**，让整个流程都在Redis里面去做，然后等秒杀介绍了，再异步的去修改库存就好了。

通过lua脚本把判断库存扣减库存的操作都写在一个脚本丢给Redis去做，避免超卖现象。到0了后面的都Return False了是吧，一个失败了你修改一个开关，直接挡住所有的请求，然后再做后面的事情嘛。
**Lua脚本是类似Redis事务，有一定的原子性，不会被其他命令插队，可以完成一些Redis事务性的操作**。

#### 限流&降级&熔断&隔离：
这个为啥要做呢，不怕一万就怕万一，万一你真的顶不住了，限流，顶不住就挡一部分出去但是不能说不行，降级，降级了还是被打挂了，熔断，至少不要影响别的系统，隔离，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊。

#### 削峰填谷：
改库是可以把请求放消息队列，然后一点点消费去改库存就好了嘛，不过单个商品其实一次修改就够了，我这里说的是某个点多个商品一起秒杀的场景，像极了双十一零点。

参考文件：

<https://blog.csdn.net/weixin_43167418/article/details/105154209>   
https://www.jianshu.com/p/c4a743bbe3a4   
<https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453140938&idx=1&sn=c0fa38a53a762b8aa9ec202e059c3a23&chksm=8cf2d749bb855e5f72bee9531799eb1516586be74235c68961a7b75746e55580b02a604fba07&scene=178&cur_album_id=1323329495885217794#rd> 

秒杀的样例：  
https://github.com/SpartaHao/JavaCoding/tree/main/seckill

## 2. 如何解决超卖现象？
**watch命令加redis事务也可以避免超卖现象；lua脚本**

不要先查库存，然后减一更新到数据库，多线程环境下会有超卖问题。用以下sql，通过数据库行锁，后续线程排队来解决超卖问题
update product set stock= stock -1 where id = #{id} and stock >0;


单机mysql也就能支持几百并发，服务器很好也就一千的并发。

使用Spring集成redis(StringRedisTemplate)比较方便
redis是单线程的，所以是线程安全的

优化0.1版，将库存值加载到缓存（decr），减完后返回值<0直接返回error。---性能提升5到6倍
有个问题就是如果数据库操作有问题，就会导致缓存的数量有问题。这时候要重新从数据库取值塞回缓存。

在内存里加一个商品已售罄的标记（Map），同时在zk下面也创建一个节点（解决分布式系统，异常情况下本地缓存数据不一致问题），如果库存<0的话，先在内存Map加上标记，然后再zk下创建一个节点，
并设置监听。调用的时候优先判断缓存标记，判断是否已售罄，如果已售罄，直接返回。**当然如果有减库存失败的情况，要恢复标记**。（zookeeper实时同步集群JVM缓存）
